Package sc;

Helpers   ////////////////////////////////////////////////////////////////////

lettre = [['a' .. 'z'] + ['A' .. 'Z']];
chiffre = ['0' .. '9'];

   Tokens //////////////////////////////////////////////////////////////////////////
id = (lettre | '_' | '$') (lettre | chiffre | '_' | '$')*; 
// TODO : check that "id" is != of 'ecrire' or 'lire' , etc ....
nb = chiffre+;
/****** Punctuation **********/
po = '(';
pf = ')';
co = '[';
cf = ']';
ao = '{';
af = '}';
comma = ',';
semicolon = ';';
/****** Operators **********/
plus = '+';
and = '&';
or = '|';
not = '!';
minus = '-';
mult = '*';
div = '/';
equal = '=';
lower_than = '<';
/****** Key words **********/
int = 'entier';
if = 'si';
then = 'alors';
else = 'sinon';
tq = 'tantque';
do = 'faire';
lire = 'lire';
ecrire = 'ecrire';
return = 'retour';
/****** Ignored signs **********/
espaces = (' ' | 13 | 10)+;
commentaire= '#' [[0 .. 0xffff] - [10 + 13]]* (10 | 13 | 10 13);

Ignored Tokens ////////////////////////////////////////////////////////////////////////

espaces, commentaire;

Productions ///////////////////////////////////////////////////////////////////////////

/************************************* Program *********************/
programme =
 {form_prog} ldv_optional ldf ;

/************************************* Functions *******************/
ldf =
 {list_func} df ldf | {eps};

df =
 {def_func} id po ldv pf ldv_optional bi;

/************************************* Variables *******************/
ldv_optional =
 {opt_var} ldv semicolon | {eps}; //////////////////// TO CHANGE

ldv =
 {l_var} dv ldv_bis | {eps}; //////////////////// TO CHANGE

ldv_bis =
 {l_var_after_comma} comma dv ldv_bis | {eps};

dv =
 {def_var} int id |
 {def_var_array} int id co nb cf
 ;//|{def_var_affectation} int id equal e;

/************************************* Instructions *****************/
bi =
 {bloc_instruction} ao li af ;

li =
 {list_instructions} i i_bis;

i_bis =
 {instruction_suiv} i i_bis | {eps} ;

i =
 {affectation} id equal e semicolon |
 {if} if e then bi else_block |
 {while} tq e do bi |
 {ret} return e semicolon |
 {function_call} id po le pf semicolon |
 {write} ecrire po e pf semicolon;

else_block =
 {else} else bi | {eps};

/************************************* Expressions *******************/
e =
 {e} e or and_e |
 {and_e} and_e;

and_e =
 {and_e} and_e and comp_e |
 {comp_e} comp_e;

comp_e =
 {equal} comp_e equal arith_low_e |
 {lower_than} comp_e lower_than arith_low_e |
 {arith_low_e} arith_low_e;

arith_low_e =
 {plus} arith_low_e plus arith_high_e |
 {moins} arith_low_e minus arith_high_e |
 {arith_high_e} arith_high_e;

arith_high_e =
 {mult} arith_high_e mult neg_e |
 {div} arith_high_e div neg_e |
 {neg_e} neg_e;

neg_e =
 {exclamation_mark} not parenth_e |
 {parenth_e} parenth_e;

parenth_e =
 {parenthesis} po element pf |
 {element} element;

element =
 {number} nb |
 {function_call} app_function |
 {read} lire po pf;

app_function =
 {def_function_call} id po le pf;

le =
 {list_expression} e e_bis | {eps};

e_bis =
 {expression_after_comma} comma e e_bis | {eps};

