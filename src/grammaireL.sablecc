Package sc;

//##############################################################\\
                             Helpers 

lettre         = [['a' .. 'z'] + ['A' .. 'Z']] ;
chiffre        = ['0' .. '9']                  ;
alpha_sign     = (lettre | '_' | '$')          ;
alpha_sign_num = ( alpha_sign | chiffre )      ;

//##############################################################\\
                             Tokens

id = alpha_sign (alpha_sign_num)*; 
nb = chiffre+;
/****** Punctuation **********/
po        = '(' ;
pf        = ')' ;
co        = '[' ;
cf        = ']' ;
ao        = '{' ;
af        = '}' ;
comma     = ',' ;
semicolon = ';' ;

/****** Mathematical Operators *******/
plus   = '+' ;
minus  = '-' ;
mult   = '*' ;
div    = '/' ;

/****** Logical Operators **********/
equal      = '=' ;
not        = '!' ;
and        = '&' ;
or         = '|' ;
lower_than = '<' ;

/****** Key words of L **********/
var_type = 'entier' ;
if       = 'si'     ;
then     = 'alors'  ;
else     = 'sinon'  ;
while    = 'tantque ';
do       = 'faire'  ;
read     = 'lire'   ;
write    = 'ecrire' ;
return   = 'retour' ;

/****** Ignored signs **********/
espaces     = (' ' | 13 | 10)+ ;
commentaire = '#' [[0 .. 0xffff] - [10 + 13]]* (10 | 13 | 10 13);

//##############################################################\\
                         Ignored Tokens 

espaces, commentaire;

//##############################################################\\
                          Productions 

/*********************** Program ********************************/
programme =
 {form_prog} ldv_optional ldf ;

/*********************** Functions ****************************/
ldf =
 {list_func} df ldf | {eps};

df =
 {def_func} id po ldv pf ldv_optional bi;

/********************** Variables *******************************/
ldv_optional =
 {opt_var} ldv semicolon | {eps}; 

ldv =
 {l_var} dv ldv_bis | {eps};

ldv_bis =
 {l_var_after_comma} comma dv ldv_bis | {eps};

dv =
 {def_var} var_type id |
 {def_var_array} var_type  id co nb cf |
 {def_var_affectation} var_type id equal e;

/********************* Instructions ***************************/
bi =
 {bloc_instruction} ao li af ;

li =
 {list_instructions} i i_bis;

i_bis =
 {instruction_suiv} i i_bis | {eps} ;

i =
 {affectation} id equal e semicolon |
 {affectation_in_array} id co nb cf equal e semicolon |
 {if} if e then bi else_block |
 {while} while e do bi |
 {ret} return e semicolon |
 {function_call} id po le pf semicolon |
 {write} write po e pf semicolon;

else_block =
 {else} else bi | {eps};

/********************* Expressions ***************************/
e =
 {e} e or and_e |
 {and_e} and_e;

and_e =
 {and_e} and_e and comp_e |
 {comp_e} comp_e;

comp_e =
 {equal} comp_e equal arith_low_e |
 {lower_than} comp_e lower_than arith_low_e |
 {arith_low_e} arith_low_e;

arith_low_e =
 {plus} arith_low_e plus arith_high_e |
 {moins} arith_low_e minus arith_high_e |
 {arith_high_e} arith_high_e;

arith_high_e =
 {mult} arith_high_e mult neg_e |
 {div} arith_high_e div neg_e |
 {neg_e} neg_e;

neg_e =
 {exclamation_mark} not parenth_e |
 {parenth_e} parenth_e;

parenth_e =
 {parenthesis} po element pf |
 {element} element;

element =
 {number} nb |
 {variable} id |
 {array} id co e cf |
 {function_call} app_function |
 {read} read po pf;

app_function =
 {def_function_call} id po le pf;

le =
 {list_expression} e e_bis | {eps};

e_bis =
 {expression_after_comma} comma e e_bis | {eps};